'use server';

import { createClient } from '@/utils/supabase/server';
import { encodedRedirect } from '@/utils/redirect';
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { prisma } from '@/lib/db';
import { UserRole } from '@prisma/client'; // Assuming UserRole enum is generated by Prisma

export const signUpAction = async (formData: FormData) => {
  const email = formData.get('email') as string;
  const password = formData.get('password') as string;
  const name = formData.get('name') as string;
  const phone = formData.get('phone') as string;
  const origin = formData.get('origin') as string;

  if (!email || !password) {
    return { error: 'Email and password are required.' };
  }

  const supabase = await createClient();

  // Check if profile already exists (for seeded admin case)
  let existingProfile = null;
  try {
    existingProfile = await prisma.profile.findUnique({
      where: { email },
      select: { id: true, role: true, email: true },
    });
  } catch (profileError) {
    console.error('Error checking existing profile:', profileError);
    // Continue with sign up even if profile check fails
  }

  // Try to sign in first (user might already exist)
  const { error: signInError } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (signInError) {
    // If sign in failed, it might be because the Supabase user doesn't exist yet
    // but the profile does (seeded admin case)
  }

  const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${origin}/auth/callback`,
    },
  });

  if (signUpError) {
    console.error('Supabase SignUp Error:', signUpError);
    if (signUpError.message.includes('User already registered')) {
      return { error: 'This email is already registered. Please sign in instead.' };
    }
    return { error: `Sign up failed: ${signUpError.message}` };
  }

  if (!signUpData.user) {
    console.error('Supabase SignUp Error: User data missing after sign up.');
    return { error: 'Sign up process failed unexpectedly. Could not retrieve user information.' };
  }

  const userId = signUpData.user.id;

  try {
    if (existingProfile) {
      // Update existing profile to link it with the new Supabase user ID
      await prisma.profile.update({
        where: { email },
        data: {
          id: userId,
          name: name || existingProfile.email.split('@')[0], // Use provided name or email prefix
          phone: phone,
          updated_at: new Date(),
        },
      });
      console.log(`Linked existing profile for ${email} to Supabase user ${userId}`);
    } else {
      // Use the new database function to ensure profile creation
      const profileResult = await prisma.$queryRaw`
        SELECT public.ensure_user_profile(
          ${userId}::uuid, 
          ${email}::text, 
          'CUSTOMER'::text
        ) as result
      `;
      
      const result = (profileResult as any)[0]?.result;
      
      if (result?.action === 'error') {
        throw new Error(`Profile creation failed: ${result.error}`);
      }
      
      // Update profile with additional information if creation was successful
      if (result?.action === 'profile_created' || result?.action === 'profile_exists') {
        await prisma.profile.update({
          where: { id: userId },
          data: {
            name: name || null,
            phone: phone,
            updated_at: new Date(),
          },
        });
      }
      
      console.log(`Profile ensured for ${email} using database function`);
    }
  } catch (profileError: any) {
    console.error('Prisma profile creation/update error during sign up:', profileError);

    // If it's a unique constraint error on email, try to handle it
    if (profileError.code === 'P2002' && profileError.meta?.target?.includes('email')) {
      try {
        // Try to update the existing profile with the new user ID
        await prisma.profile.update({
          where: { email },
          data: {
            id: userId,
            updated_at: new Date(),
          },
        });
        console.log(`Updated existing profile for ${email} with new user ID`);
      } catch (updateError) {
        console.error('Failed to update existing profile:', updateError);
        return { error: `Account created, but profile linking failed. Please contact support.` };
      }
    } else {
      // Fallback: try to create profile directly
      try {
        await prisma.profile.create({
          data: {
            id: userId,
            email: email,
            name: name || null,
            phone: phone,
            role: UserRole.CUSTOMER,
            updated_at: new Date(),
          },
        });
        console.log(`Created profile for ${email} using fallback method`);
      } catch (fallbackError) {
        console.error('Fallback profile creation also failed:', fallbackError);
        return {
          error: `Account created, but profile setup failed: ${profileError.message}. Please contact support.`,
        };
      }
    }
  }

  return { success: 'Sign up successful! Please check your email for verification.' };
};

export const signInAction = async (formData: FormData) => {
  const email = formData.get('email') as string;
  const password = formData.get('password') as string;
  const redirectUrl = formData.get('redirect') as string;
  const supabase = await createClient();

  const { error: signInError } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (signInError) {
    return encodedRedirect('error', '/sign-in', signInError.message);
  }

  // After successful sign-in, get user and their profile
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    // Should not happen after successful sign-in, but handle defensively
    return encodedRedirect('error', '/sign-in', 'Could not retrieve user after sign in.');
  }

  let profile: { role: UserRole } | null = null;
  let profileFetchError: any = null; // Use 'any' or a more specific error type if known

  try {
    // Try block ONLY for prisma query
    profile = await prisma.profile.findUnique({
      where: { id: user.id },
      select: { role: true }, // Only select the role field
    });
  } catch (dbError) {
    // Catch ONLY potential database errors
    profileFetchError = dbError; // Store the error
    console.error('Prisma profile fetch error:', JSON.stringify(dbError, null, 2));
    // Redirect immediately if the database query itself fails
    return encodedRedirect('error', '/sign-in', 'Database error retrieving user profile.');
  }

  // Handle profile not found case (outside the try...catch)
  if (!profile) {
    // Log the specific error for tracking
    console.error(`Sign-in error: Profile not found for user ${user.id}`);

    try {
      // Use the new database function to ensure profile creation
      const profileResult = await prisma.$queryRaw`
        SELECT public.ensure_user_profile(
          ${user.id}::uuid, 
          ${user.email || email}::text, 
          'CUSTOMER'::text
        ) as result
      `;
      
      const result = (profileResult as any)[0]?.result;
      
      if (result?.action === 'error') {
        throw new Error(`Profile creation failed: ${result.error}`);
      }
      
      // Fetch the newly created profile
      if (result?.action === 'profile_created' || result?.action === 'profile_exists') {
        profile = await prisma.profile.findUnique({
          where: { id: user.id },
          select: { role: true },
        });
      }
      
      // If still no profile, try fallback method
      if (!profile) {
        // Auto-create a basic profile for the user with default role
        const authName = user.user_metadata?.name as string | undefined;
        const authPhone = user.user_metadata?.phone as string | undefined;

        profile = await prisma.profile.create({
          data: {
            id: user.id,
            email: user.email || email,
            name: authName || null,
            phone: authPhone || null,
            role: UserRole.CUSTOMER,
            updated_at: new Date(),
          },
          select: { role: true },
        });

        console.log(`Created new profile for user ${user.id} during sign-in using fallback`);
      } else {
        console.log(`Profile ensured for user ${user.id} using database function`);
      }
    } catch (createError) {
      console.error(`Failed to create profile for user ${user.id} during sign-in:`, createError);
      // If profile creation fails, inform the user with a clear error message
      return encodedRedirect(
        'error',
        '/sign-in',
        'User profile could not be created. Please contact support.'
      );
    }

    // Double-check that profile was created successfully
    if (!profile) {
      return encodedRedirect(
        'error',
        '/sign-in',
        'Unable to create user profile. Please contact support.'
      );
    }
  }

  // Profile fetched or created successfully, perform redirect based on role and redirect parameter
  if (profile.role === UserRole.ADMIN) {
    // Use Prisma enum for role comparison
    return redirect('/admin');
  } else {
    // For non-admin users, use the redirect URL if provided, otherwise default to menu
    return redirect(redirectUrl || '/menu');
  }
};

export const forgotPasswordAction = async (formData: FormData) => {
  const email = formData.get('email')?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get('origin');
  const callbackUrl = formData.get('callbackUrl')?.toString();

  if (!email) {
    return encodedRedirect('error', '/forgot-password', 'Email is required');
  }

  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${origin}/auth/callback?redirect_to=/protected/reset-password`,
  });

  if (error) {
    console.error(error.message);
    return encodedRedirect('error', '/forgot-password', 'Could not reset password');
  }

  if (callbackUrl) {
    return redirect(callbackUrl);
  }

  return encodedRedirect(
    'success',
    '/forgot-password',
    'Check your email for a link to reset your password.'
  );
};

export const resetPasswordAction = async (formData: FormData) => {
  const supabase = await createClient();

  const password = formData.get('password') as string;
  const confirmPassword = formData.get('confirmPassword') as string;

  if (!password || !confirmPassword) {
    return encodedRedirect(
      'error',
      '/protected/reset-password',
      'Password and confirm password are required'
    );
  }

  if (password !== confirmPassword) {
    return encodedRedirect('error', '/protected/reset-password', 'Passwords do not match');
  }

  const { error } = await supabase.auth.updateUser({
    password: password,
  });

  if (error) {
    return encodedRedirect('error', '/protected/reset-password', 'Password update failed');
  }

  // Redirect to account page with success message
  return encodedRedirect('success', '/account', 'Your password has been updated successfully');
};

export const setupPasswordAction = async (formData: FormData) => {
  const password = formData.get('password') as string;
  const confirmPassword = formData.get('confirmPassword') as string;
  const supabase = await createClient();

  // Validate password requirements
  if (!password || !confirmPassword) {
    return encodedRedirect(
      'error',
      '/setup-password',
      'Password and confirm password are required'
    );
  }

  if (password !== confirmPassword) {
    return encodedRedirect('error', '/setup-password', 'Passwords do not match');
  }

  // Validate password strength
  const passwordRequirements = [
    {
      test: (pwd: string) => pwd.length >= 8,
      message: 'Password must be at least 8 characters long',
    },
    {
      test: (pwd: string) => /[A-Z]/.test(pwd),
      message: 'Password must contain an uppercase letter',
    },
    {
      test: (pwd: string) => /[a-z]/.test(pwd),
      message: 'Password must contain a lowercase letter',
    },
    { test: (pwd: string) => /\d/.test(pwd), message: 'Password must contain a number' },
    {
      test: (pwd: string) => /[!@#$%^&*(),.?":{}|<>]/.test(pwd),
      message: 'Password must contain a special character',
    },
  ];

  for (const requirement of passwordRequirements) {
    if (!requirement.test(password)) {
      return encodedRedirect('error', '/setup-password', requirement.message);
    }
  }

  // Get current user (should be authenticated via invitation link)
  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser();

  if (userError || !user) {
    return encodedRedirect(
      'error',
      '/setup-password',
      'Authentication required. Please use the invitation link.'
    );
  }

  // Update the user's password
  const { error: updateError } = await supabase.auth.updateUser({
    password: password,
  });

  if (updateError) {
    console.error('Password setup error:', updateError);
    return encodedRedirect(
      'error',
      '/setup-password',
      'Failed to set up password. Please try again.'
    );
  }

  // Check if user has a profile, if not create one
  try {
    const existingProfile = await prisma.profile.findUnique({
      where: { id: user.id },
    });

    if (!existingProfile) {
      // Create profile if it doesn't exist (shouldn't happen with admin-created users, but safety check)
      await prisma.profile.create({
        data: {
          id: user.id,
          email: user.email!,
          name: user.user_metadata?.name || null,
          phone: user.user_metadata?.phone || null,
          role: UserRole.CUSTOMER,
        },
      });
    }
  } catch (profileError) {
    console.error('Profile check/creation error during password setup:', profileError);
    // Don't fail the password setup for profile issues, just log it
  }

  // Redirect to sign-in with success message
  return encodedRedirect(
    'success',
    '/sign-in',
    'Password set up successfully! You can now sign in with your new password.'
  );
};

export const signOutAction = async () => {
  const supabase = await createClient();
  await supabase.auth.signOut();
  return redirect('/sign-in');
};

export const magicLinkSignInAction = async (formData: FormData) => {
  const email = formData.get('email')?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get('origin');
  const redirectUrl = formData.get('redirect')?.toString();

  if (!email) {
    return encodedRedirect('error', '/sign-in', 'Email is required');
  }

  // Check if user exists in our database
  let existingProfile;
  try {
    existingProfile = await prisma.profile.findUnique({
      where: { email },
      select: { id: true, email: true, role: true },
    });
  } catch (dbError) {
    console.error('Database error during magic link profile lookup:', dbError);
    return encodedRedirect('error', '/sign-in', 'Database error. Please try again.');
  }

  if (!existingProfile) {
    return encodedRedirect(
      'error',
      '/sign-in',
      'No account found with this email. Please sign up first or use a different email.'
    );
  }

  // Determine redirect destination based on role and redirect parameter
  let redirectTo = '/menu'; // default for customers
  if (existingProfile.role === 'ADMIN') {
    redirectTo = '/admin';
  } else if (redirectUrl) {
    redirectTo = redirectUrl;
  }

  console.log('🪄 Sending magic link:', {
    email,
    origin,
    redirectTo,
    fullRedirectUrl: `${origin}/auth/callback?redirect_to=${redirectTo}`,
  });

  // Send magic link using OTP flow
  const { error } = await supabase.auth.signInWithOtp({
    email,
    options: {
      emailRedirectTo: `${origin}/auth/callback?redirect_to=${redirectTo}`,
      // Ensure this is treated as a magic link OTP, not PKCE
      shouldCreateUser: false, // Don't create new users through magic link
    },
  });

  if (error) {
    console.error('Magic link error:', error.message);

    // Provide more specific error messages
    if (error.message.includes('email not confirmed')) {
      return encodedRedirect('error', '/sign-in', 'Please verify your email address first.');
    } else if (error.message.includes('signup')) {
      return encodedRedirect('error', '/sign-in', 'Account not found. Please sign up first.');
    } else {
      return encodedRedirect('error', '/sign-in', 'Could not send magic link. Please try again.');
    }
  }

  console.log('✅ Magic link sent successfully to:', email);

  return encodedRedirect('success', '/sign-in', 'Check your email for a magic link to sign in!');
};
